--- a/drivers/android/binder.c	2025-04-09 22:42:07.982722953 +0800
+++ b/drivers/android/binder.c	2025-04-09 22:43:35.617711344 +0800
@@ -69,6 +69,7 @@
 
 #include <uapi/linux/sched/types.h>
 #include <uapi/linux/android/binder.h>
+#include <linux/rekernel.h>
 
 #include <asm/cacheflush.h>
 
@@ -3240,6 +3241,18 @@
 			goto err_dead_binder;
 		}
 		e->to_node = target_node->debug_id;
+		if (start_rekernel_server() == 0) {
+			if (target_proc
+				&& (NULL != target_proc->tsk)
+				&& (NULL != proc->tsk)
+				&& (task_uid(target_proc->tsk).val > REKERNEL_MIN_USERAPP_UID)
+				&& (proc->pid != target_proc->pid)
+				&& line_is_frozen(target_proc->tsk)) {
+				char binder_kmsg[REKERNEL_PACKET_SIZE];
+			snprintf(binder_kmsg, sizeof(binder_kmsg), "type=Binder,bindertype=transaction,oneway=%d,from_pid=%d,from=%d,target_pid=%d,target=%d;",  tr->flags & TF_ONE_WAY, proc->pid, task_uid(proc->tsk).val, target_proc->pid, task_uid(target_proc->tsk).val);
+			send_netlink_message(binder_kmsg, strlen(binder_kmsg));
+				}
+		}
 		if (WARN_ON(proc == target_proc)) {
 			return_error = BR_FAILED_REPLY;
 			return_error_param = -EINVAL;

--- a/drivers/android/binder_alloc.c	2025-04-09 22:42:07.984792413 +0800
+++ b/drivers/android/binder_alloc.c	2025-04-09 22:45:29.102695891 +0800
@@ -450,7 +450,52 @@
 }
 
 /* Callers preallocate @new_buffer, it is freed by this function if unused */
-static struct binder_buffer *binder_alloc_new_buf_locked(
+static static inline bool line_is_frozen(struct task_struct *task)
+{
+	return frozen(task) || freezing(task);
+}
+
+static int send_netlink_message(char *msg, uint16_t len) {
+    struct sk_buff *skbuffer;
+    struct nlmsghdr *nlhdr;
+
+    skbuffer = nlmsg_new(len, GFP_ATOMIC);
+    if (!skbuffer) {
+        printk("netlink alloc failure.\n");
+        return -1;
+    }
+
+    nlhdr = nlmsg_put(skbuffer, 0, 0, rekernel_netlink_unit, len, 0);
+    if (!nlhdr) {
+        printk("nlmsg_put failaure.\n");
+        nlmsg_free(skbuffer);
+        return -1;
+    }
+
+    memcpy(nlmsg_data(nlhdr), msg, len);
+    return netlink_unicast(rekernel_netlink, skbuffer, REKERNEL_USER_PORT, MSG_DONTWAIT);
+}
+
+static int start_rekernel_server(void) {
+  extern struct net init_net;
+  struct netlink_kernel_cfg rekernel_cfg = {
+    .input = NULL,
+  };
+  if (rekernel_netlink != NULL)
+    return 0;
+  for (rekernel_netlink_unit = NETLINK_REKERNEL_MIN; rekernel_netlink_unit < NETLINK_REKERNEL_MAX; rekernel_netlink_unit++) {
+    rekernel_netlink = (struct sock *)netlink_kernel_create(&init_net, rekernel_netlink_unit, &rekernel_cfg);
+    if (rekernel_netlink != NULL)
+      break;
+  }
+  printk("Created Re:Kernel server! NETLINK UNIT: %d\n", rekernel_netlink_unit);
+  if (rekernel_netlink == NULL) {
+    printk("Failed to create Re:Kernel server!\n");
+    return -1;
+  }
+  return 0;
+}
+struct binder_buffer *binder_alloc_new_buf_locked(
 				struct binder_alloc *alloc,
 				struct binder_buffer *new_buffer,
 				size_t size,
@@ -472,6 +517,21 @@
 		goto out;
 	}
 
+	if (is_async
+		&& (alloc->free_async_space < 3 * (size + sizeof(struct binder_buffer))
+		|| (alloc->free_async_space < REKERNEL_WARN_AHEAD_SPACE))) {
+		rcu_read_lock();
+		proc_task = find_task_by_vpid(alloc->pid);
+		rcu_read_unlock();
+		if (proc_task != NULL && start_rekernel_server() == 0) {
+			if (line_is_frozen(proc_task)) {
+     			char binder_kmsg[REKERNEL_PACKET_SIZE];
+                snprintf(binder_kmsg, sizeof(binder_kmsg), "type=Binder,bindertype=free_buffer_full,oneway=1,from_pid=%d,from=%d,target_pid=%d,target=%d;", current->pid, task_uid(current).val, proc_task->pid, task_uid(proc_task).val);
+         		send_netlink_message(binder_kmsg, strlen(binder_kmsg));
+			}
+		}
+	}
+
 	while (n) {
 		buffer = rb_entry(n, struct binder_buffer, rb_node);
 		BUG_ON(!buffer->free);
